from google.adk.agents import LlmAgent, BaseAgent, SequentialAgent, LoopAgent
from google.adk.events import Event, EventActions
from google.adk.agents.invocation_context import InvocationContext
from google.adk.tools import FunctionTool
from typing import AsyncGenerator, Dict, Any, Optional
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.genai import types

from utils import *

api_key = os.environ['GOOGLE_API_KEY']


# Function to execute SQL query (would be implemented with actual DB connection)
async def execute_sql_query(query: str) -> Dict[str, Any]:
    """Execute SQL query and return results"""
    return {"data": f"Results for query:  {query}", "success": True}

# Function to convert data to CSV
async def convert_to_csv(data: Dict[str, Any]) -> str:
    """Convert data to CSV format"""
    return data['data']

# Create tools for SQL execution and CSV conversion
sql_execution_tool = FunctionTool(func=execute_sql_query)
csv_conversion_tool = FunctionTool(func=convert_to_csv)

# Root Agent - Routes user queries to appropriate specialized agents
root_agent = LlmAgent(
    name="RouterAgent",
    model="gemini-2.0-flash",
    description="Routes user queries to appropriate specialized agents based on query type",
    instruction="""
    You are a router agent that analyzes user queries and routes them to the appropriate specialized agent.
    If the query is about sales data, route it to the SalesAgent.
    For other types of SQL queries, you'll need to route to other specialized agents [CustomerAgent, InsuranceAgent, LoanAgent].
    
    Use 'transfer_to_agent' function to route the query to the appropriate agent.
    
    "Strictly call the tool and get the system prompt first, then decided to which sub_agent to transfer the task."
    "Given a query from user, use the tool first 'generate_system_prompt' and wait till its response."
    "Use the provided schema metadata and similar examples to route to the appropriate specialized agent. "
    
    "If you encounter any ambiguities or potential confusion when analyzing the table schemas, such as:"
        "- Tables with similar column names but different purposes"
        "- Unclear relationships between tables"
        "- Multiple possible join paths"
        "- Ambiguous column references in the user's question"
        "- Overlapping functionality across different tables"
    "Then explicitly ask the user for clarification before proceeding with query generation."
    
    "Only after resolving any schema ambiguities should you generate the SQL query."
    "Your response should include the SQL query and an explanation of what it does and why specific joins, filters, "
    "or aggregations were chosen. Format SQL with proper indentation for readability."
    
    
    "Also it is very import to pass the relevant table_name, column_name, description, etc. to the sub_agents as generated by the 'generate_system_prompt' tool."
    """ ,
    tools=[generate_system_prompt]
)

# Specific Agent for Sales queries
sales_agent = LlmAgent(
    name="SalesAgent",
    model="gemini-2.0-flash",
    description="Handles sales-related SQL queries",
    instruction="""
    You are a specialized agent for handling sales-related queries.
    
    You have bounded context given by the root_agent.
    
    For user queries:
    1. If you're sure how to handle it, convert it to a valid SQL query
    2. If unsure about the query details, use the LoopBackAgent to get clarification
        "When asking for clarification:"
            "1. Clearly explain the specific schema confusion you've identified"
            "2. Present the competing interpretations or options"
            "3. Ask a targeted question that will resolve the ambiguity"
    3. Store the final SQL query in state['sql_query']
    """,
    output_key="sql_query"
)


# Customer Query Agent
customer_agent = LlmAgent(
    name="CustomerAgent",
    model="gemini-2.0-flash",
    description="Handles customer-related SQL queries",
    instruction="""
    You are a specialized agent for handling customer-related queries.
    
    You have bounded context given by the root_agent.
    
    
    For user queries:
    1. If you're sure how to handle it, convert it to a valid SQL query
    2. If unsure about the query details, use the LoopBackAgent to get clarification
        "When asking for clarification:"
            "1. Clearly explain the specific schema confusion you've identified"
            "2. Present the competing interpretations or options"
            "3. Ask a targeted question that will resolve the ambiguity"
    3. Store the final SQL query in state['sql_query']
    """,
    output_key="sql_query"
)

# Insurance Query Agent
insurance_agent = LlmAgent(
    name="InsuranceAgent",
    model="gemini-2.0-flash",
    description="Handles insurance-related SQL queries",
    instruction="""
    You are a specialized agent for handling insurance-related queries.
    
    You have bounded context given by the root_agent.
    
    For user queries:
    1. If you're sure how to handle it, convert it to a valid SQL query
    2. If unsure about the query details, use the LoopBackAgent to get clarification
        "When asking for clarification:"
            "1. Clearly explain the specific schema confusion you've identified"
            "2. Present the competing interpretations or options"
            "3. Ask a targeted question that will resolve the ambiguity"
    3. Store the final SQL query in state['sql_query']
    """,
    output_key="sql_query"
)

# Loan Query Agent
loan_agent = LlmAgent(
    name="LoanAgent",
    model="gemini-2.0-flash",
    description="Handles loan-related SQL queries",
    instruction="""
    You are a specialized agent for handling loan-related queries.
    
    You have bounded context given by the root_agent.
    
    
    For user queries:
    1. If you're sure how to handle it, convert it to a valid SQL query
    2. If unsure about the query details, use the LoopBackAgent to get clarification
        "When asking for clarification:"
            "1. Clearly explain the specific schema confusion you've identified"
            "2. Present the competing interpretations or options"
            "3. Ask a targeted question that will resolve the ambiguity"
    3. Store the final SQL query in state['sql_query']
    """,
    output_key="sql_query"
)

# class LoopBackAgent(BaseAgent):
#     name: str = "LoopBackAgent"
#     description: str = "Asks for clarification when the query is ambiguous"
    
#     async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
#         # Get the original query and any specific clarification needed
#         original_query = ctx.session.state.get("original_query", "")
#         clarification_needed = ctx.session.state.get("clarification_needed", "")
        
#         # Generate a clarification request
#         clarification_prompt = f"I need clarification on your query about '{original_query}'."
#         if clarification_needed:
#             clarification_prompt += f" Specifically, could you provide more details about {clarification_needed}?"
#         else:
#             clarification_prompt += " Could you provide more specific details?"
        
#         # Send the clarification request to the user
#         yield Event(
#             author=self.name,
#             content=clarification_prompt,
#             # This flag indicates we're expecting a response
#             actions=EventActions(
#                 expect_response=True
#             )
#         )
        
#         # Wait for user's clarification response
#         # The ADK framework will pause execution here until user input is received
#         # The next event will contain the user's response
#         user_response = await ctx.receive_event()
        
#         if user_response and user_response.content:
#             # Store the clarification in the session state
#             ctx.session.state["clarification"] = user_response.content
            
#             # Optionally, you can update the original query with the clarification
#             combined_query = f"{original_query} {user_response.content}"
#             ctx.session.state["enhanced_query"] = combined_query
            
#             # Acknowledge receipt of clarification
#             yield Event(
#                 author=self.name,
#                 content=f"Thank you for the clarification. I'll process your request now.",
#                 actions=EventActions(
#                     # Update state with the clarification
#                     state_delta={
#                         "clarification_received": True,
#                         "clarification_text": user_response.content
#                     }
#                 )
#             )
#         else:
#             # Handle case where no valid response was received
#             yield Event(
#                 author=self.name,
#                 content="I didn't receive a clear response. I'll try to process your original query.",
#                 actions=EventActions(
#                     state_delta={"clarification_received": False}
#                 )
#             )

class LoopBackAgent(BaseAgent):
    name: str = "LoopBackAgent"
    description: str = "Asks for clarification when the query is ambiguous"
    
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        # Get the original query and any specific clarification needed
        original_query = ctx.session.state.get("original_query", "")
        clarification_needed = ctx.session.state.get("clarification_needed", "")
        
        # Generate a clarification request
        clarification_prompt = f"I need clarification on your query about '{original_query}'."
        if clarification_needed:
            clarification_prompt += f" Specifically, could you provide more details about {clarification_needed}?"
        else:
            clarification_prompt += " Could you provide more specific details?"
        
        # Send the clarification request to the user
        # Instead of using expect_response, use should_await_response in state_delta
        yield Event(
            author=self.name,
            content=clarification_prompt,
            actions=EventActions(
                state_delta={"should_await_response": True}
            )
        )
        
        # Wait for user's clarification response
        # Use the proper method to wait for user input
        user_response = await ctx.receive_user_response()
        
        if user_response and hasattr(user_response, 'content') and user_response.content:
            # Store the clarification in the session state
            ctx.session.state["clarification"] = user_response.content
            
            # Optionally, update the original query with the clarification
            combined_query = f"{original_query} {user_response.content}"
            ctx.session.state["enhanced_query"] = combined_query
            
            # Acknowledge receipt of clarification
            yield Event(
                author=self.name,
                content=f"Thank you for the clarification. I'll process your request now.",
                actions=EventActions(
                    state_delta={
                        "clarification_received": True,
                        "clarification_text": user_response.content
                    }
                )
            )
        else:
            # Handle case where no valid response was received
            yield Event(
                author=self.name,
                content="I didn't receive a clear response. I'll try to process your original query.",
                actions=EventActions(
                    state_delta={"clarification_received": False}
                )
            )

# SQL Query Execution Agent
class SqlQueryAgent(BaseAgent):
    name: str = "SqlQueryAgent"
    description: str = "Executes SQL queries against the database"
    
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        sql_query = ctx.session.state.get("sql_query")
        if not sql_query:
            yield Event(author=self.name, content="No SQL query found in state")
            return
            
        # Execute the SQL query using the tool
        result = await sql_execution_tool.run_async(ctx, query=sql_query)
        
        # Store the result in state
        ctx.session.state["query_result"] = result
        
        yield Event(author=self.name, content=f"Query executed successfully")

# Data Formatting Agent
class DataFormattingAgent(BaseAgent):
    name: str = "DataFormattingAgent"
    description: str = "Formats data into the requested output format (CSV)"
    
    async def _run_async_impl(self, ctx: InvocationContext) -> AsyncGenerator[Event, None]:
        result = ctx.session.state.get("query_result")
        if not result:
            yield Event(author=self.name, content="No query result found in state")
            return
            
        # Convert the data to CSV
        csv_data = await csv_conversion_tool.run_async(ctx, data=result)
        
        # Store the formatted data in state
        ctx.session.state["formatted_output"] = csv_data
        
        yield Event(author=self.name, content=f"Data formatted as CSV {csv_data}")

# Set up the hierarchy - make sales_agent a sub_agent of root_agent
root_agent.sub_agents = [sales_agent, customer_agent, insurance_agent, loan_agent]

sql_execution_agent = SqlQueryAgent()
DataFormattingAgent = DataFormattingAgent()

# Connect the loop back agent to each specialized agent
# loop_back = LoopBackAgent()

# Connect the loop back agent to each specialized agent
# sales_agent.sub_agents = [loop_back]
# customer_agent.sub_agents = [loop_back]
# insurance_agent.sub_agents = [loop_back]
# loan_agent.sub_agents = [loop_back]

# Create the workflow pipeline
query_workflow = SequentialAgent(
    name="QueryWorkflow",
    description="Processes user queries through a workflow of specialized agents",
    sub_agents=[
        root_agent,     # Routes to specialized agent
                        # Note: The actual flow will depend on the router's decision
                        # The specialized agent (e.g., SalesAgent) would be invoked via transfer_to_agent
                        # After that, the following agents would process the results
        sql_execution_agent,
        DataFormattingAgent
    ]
)


# ----------------------------------------------------------------------------------------------------------------------------------------------

# Create session service and session
session_service = InMemorySessionService()

APP_NAME = "sql_query_adv_app"
USER_ID = "user_69"
SESSION_ID = "session_007"

# Create the specific session where the conversation will happen
session = session_service.create_session(
    app_name=APP_NAME,
    user_id=USER_ID,
    session_id=SESSION_ID
)
print(f"Session created: App='{APP_NAME}', User='{USER_ID}', Session='{SESSION_ID}'")

# Create the runner
runner = Runner(
    agent=query_workflow,
    app_name=APP_NAME,
    session_service=session_service
)
print(f"Runner created for agent '{runner.agent.name}'.")

async def generate_sql_from_nl(query: str):
    """Sends a natural language query to the agent and returns the SQL response."""
    print(f"\n>>> User Query: {query}")

    # Prepare the user's message in ADK format
    content = types.Content(role='user', parts=[types.Part(text=query)])

    final_response_text = "Agent did not produce a final response."  # default

    async for event in runner.run_async(user_id=USER_ID, session_id=SESSION_ID, new_message=content):
        if event.is_final_response():
            if event.content and event.content.parts:
                # Assuming text response in the first part
                final_response_text = event.content.parts[0].text
            elif event.actions and event.actions.escalate:  # Handle potential errors/escalations
                final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
            break

    print(f"<<< Agent Response: {final_response_text}")
    return final_response_text
